require('dotenv').config()
const core = require('@actions/core')
const github = require('@actions/github')
const { Octokit } = require('@octokit/rest')
const Jira = require('./../utils/jira')
const fs = require('node:fs')

/**
 * Mask sensitive data in logs.
 * @param {object} obj - Any object to mask
 * @returns {object}
 */
function maskSensitive (obj) {
  if (!obj || typeof obj !== 'object') return obj
  const clone = structuredClone(obj)
  if (clone.apiToken) clone.apiToken = '***'
  if (clone.email) clone.email = '***'
  if (clone.headers?.Authorization) clone.headers.Authorization = '***'
  if (clone.JIRA_API_TOKEN) clone.JIRA_API_TOKEN = '***'
  if (clone.JIRA_EMAIL) clone.JIRA_EMAIL = '***'
  return clone
}

/**
 * Detect environment: 'ci', 'github', or 'local'.
 * @returns {'ci'|'github'|'local'}
 */
function detectEnvironment () {
  if (process.env.GITHUB_ACTIONS === 'true') return 'github'
  if (process.env.CI === 'true') return 'ci'
  return 'local'
}

const ENVIRONMENT = detectEnvironment()
/**
 * Log environment and startup info (professional, clear, masked).
 */
function logEnvSection () {
  console.log('\n====================')
  console.log('Coursedog: update_jira script startup')
  console.log('Environment:', ENVIRONMENT)
  console.log('GITHUB_REF:', process.env.GITHUB_REF)
  console.log('GITHUB_EVENT_NAME:', process.env.GITHUB_EVENT_NAME)
  console.log('GITHUB_EVENT_PATH:', process.env.GITHUB_EVENT_PATH)
  console.log('GITHUB_REPOSITORY:', process.env.GITHUB_REPOSITORY)
  console.log('JIRA_BASE_URL:', process.env.JIRA_BASE_URL)
  console.log('JIRA_EMAIL:', process.env.JIRA_EMAIL ? '***' : undefined)
  console.log('JIRA_PROJECT_KEY:', process.env.JIRA_PROJECT_KEY)
  console.log('====================\n')
}

/**
 * Professional debug logger with masking and clear formatting.
 * @param {string} message
 * @param  {...any} args
 */
function debugLog (message, ...args) {
  const safeArgs = args.map(maskSensitive)
  console.log(`[DEBUG] ${message}`, ...safeArgs)
}

logEnvSection()

/**
 * Custom Field Configuration for Deployment Tracking
 *
 * These custom field IDs are defined in Jira and used to track deployment metadata.
 * Reference: Ticket ALL-593
 *
 * Custom Fields:
 * - customfield_11473: Release Environment (select field)
 *   Options: staging (ID: 11942), production (ID: 11943)
 * - customfield_11474: Stage Release Timestamp (datetime)
 * - customfield_11475: Production Release Timestamp (datetime)
 *
 * To verify these IDs match your Jira instance:
 *   node utils/verify-custom-fields.js
 *
 * To test updating these fields:
 *   node utils/test-custom-field-update.js [ISSUE_KEY]
 */
const stagingReleaseEnvId = '11942' // Option ID for "staging" in customfield_11473
const prodReleaseEnvId = '11943' // Option ID for "production" in customfield_11473

/**
 * Status mapping configuration for different branch deployments.
 * Maps branch names to their corresponding Jira status and custom field updates.
 *
 * When code is merged/pushed to these branches:
 * - master/main: Production deployment → sets Production Release Timestamp
 * - staging: Staging deployment → sets Stage Release Timestamp
 * - dev: Development merge → no deployment timestamps set
 */
const statusMap = {
  master: {
    status: 'Done',
    transitionFields: {
      resolution: 'Done',
    },
    customFields: {
      customfield_11475: new Date(),
      customfield_11473: { id: prodReleaseEnvId },
    },
  },
  main: {
    status: 'Done',
    transitionFields: {
      resolution: 'Done',
    },
    customFields: {
      customfield_11475: new Date(),
      customfield_11473: { id: prodReleaseEnvId },
    },
  },
  staging: {
    status: 'Deployed to Staging',
    transitionFields: {
      resolution: 'Done', // CRITICAL FIX: Jira workflow requires resolution for this transition
    },
    customFields: {
      customfield_11474: new Date(),
      customfield_11473: { id: stagingReleaseEnvId },
    },
  },
  dev: {
    status: 'Merged',
    transitionFields: {
      // No resolution field - "Merged" is not a final state
    },
    customFields: {},
  },
}

run()

async function run () {
  try {
    debugLog(
      'run() started. Checking event type and initializing Jira connection.'
    )
    debugLog(
      'Rollback/dry-run mode:',
      process.env.DRY_RUN === 'true' ? 'ENABLED' : 'DISABLED'
    )
    const {
      GITHUB_REF,
      GITHUB_EVENT_NAME,
      GITHUB_EVENT_PATH,
      GITHUB_REPOSITORY,
      GITHUB_TOKEN,
    } = process.env

    const JIRA_BASE_URL =
      core.getInput('JIRA_BASE_URL') || process.env.JIRA_BASE_URL
    const JIRA_EMAIL = core.getInput('JIRA_EMAIL') || process.env.JIRA_EMAIL
    const JIRA_API_TOKEN =
      core.getInput('JIRA_API_TOKEN') || process.env.JIRA_API_TOKEN

    debugLog('Attempting to initialize Jira utility with:', {
      JIRA_BASE_URL,
      JIRA_EMAIL,
      JIRA_API_TOKEN: JIRA_API_TOKEN ? '***' : undefined,
    })
    const jiraUtil = new Jira({
      baseUrl: JIRA_BASE_URL,
      email: JIRA_EMAIL,
      apiToken: JIRA_API_TOKEN,
      logLevel: process.env.DEBUG === 'true' ? 'DEBUG' : 'INFO',
    })
    debugLog('Jira utility initialized.')

    // --- EVENT PAYLOAD HANDLING ---
    let eventData = null
    if (ENVIRONMENT === 'local') {
      // Allow local override of event payload for testing
      const localEventPath = './update_jira/event.local.json'
      if (fs.existsSync(localEventPath)) {
        debugLog('Detected local event payload override:', localEventPath)
        eventData = JSON.parse(fs.readFileSync(localEventPath, 'utf8'))
      } else if (GITHUB_EVENT_PATH && fs.existsSync(GITHUB_EVENT_PATH)) {
        debugLog(
          'Loading event payload from GITHUB_EVENT_PATH:',
          GITHUB_EVENT_PATH
        )
        eventData = JSON.parse(fs.readFileSync(GITHUB_EVENT_PATH, 'utf8'))
      } else {
        debugLog('No event payload found for local run.')
      }
    } else if (GITHUB_EVENT_PATH && fs.existsSync(GITHUB_EVENT_PATH)) {
      debugLog(
        'Loading event payload from GITHUB_EVENT_PATH:',
        GITHUB_EVENT_PATH
      )
      eventData = JSON.parse(fs.readFileSync(GITHUB_EVENT_PATH, 'utf8'))
    }

    if (
      (GITHUB_EVENT_NAME === 'pull_request' ||
        GITHUB_EVENT_NAME === 'pull_request_target') &&
      eventData
    ) {
      debugLog(
        'Detected pull request event. Loaded event data:',
        maskSensitive(eventData)
      )
      if (process.env.DRY_RUN === 'true') {
        debugLog(
          'DRY RUN: Would handle pull request event, skipping actual Jira update.'
        )
        return
      }
      await handlePullRequestEvent(eventData, jiraUtil, GITHUB_REPOSITORY)
      return
    }

    const allowedBranches = [
      'refs/heads/master',
      'refs/heads/main',
      'refs/heads/staging',
      'refs/heads/dev',
    ]

    if (allowedBranches.includes(GITHUB_REF)) {
      const branchName = GITHUB_REF.split('/').pop()
      debugLog('Detected push event for branch:', branchName)
      if (process.env.DRY_RUN === 'true') {
        debugLog(
          'DRY RUN: Would handle push event, skipping actual Jira update.'
        )
        return
      }
      await handlePushEvent(
        branchName,
        jiraUtil,
        GITHUB_REPOSITORY,
        GITHUB_TOKEN
      )
    }
  } catch (error) {
    debugLog('Error in run():', error)
    core.setFailed(error.message)
  }
}

/**
 * Prepare fields for Jira transition, converting names to IDs where needed
 */
async function prepareFields (fields, jiraUtil) {
  const preparedFields = {}

  for (const [ fieldName, fieldValue ] of Object.entries(fields)) {
    if (fieldName === 'resolution' && typeof fieldValue === 'string') {
      // Look up resolution ID by name
      const resolutions = await jiraUtil.getFieldOptions('resolution')
      const resolution = resolutions.find((r) => r.name === fieldValue)
      if (resolution) {
        preparedFields.resolution = { id: resolution.id }
      } else {
        console.warn(`Resolution "${fieldValue}" not found`)
      }
    } else if (fieldName === 'priority' && typeof fieldValue === 'string') {
      // Look up priority ID by name
      const priorities = await jiraUtil.getFieldOptions('priority')
      const priority = priorities.find((p) => p.name === fieldValue)
      if (priority) {
        preparedFields.priority = { id: priority.id }
      }
    } else if (fieldName === 'assignee' && typeof fieldValue === 'string') {
      // For assignee, you might need to look up the user
      // This depends on your Jira configuration
      preparedFields.assignee = { name: fieldValue }
    } else {
      // Pass through other fields as-is
      preparedFields[fieldName] = fieldValue
    }
  }

  return preparedFields
}

/**
 * Update issue with transition and then update custom fields separately
 */
async function updateIssueWithCustomFields (
  jiraUtil,
  issueKey,
  targetStatus,
  excludeStates,
  transitionFields,
  customFields
) {
  try {
    // First, transition the issue with only transition-allowed fields
    const preparedTransitionFields = await prepareFields(
      transitionFields,
      jiraUtil
    )
    await jiraUtil.transitionIssue(
      issueKey,
      targetStatus,
      excludeStates,
      preparedTransitionFields
    )

    // Then, if there are custom fields to update, update them separately
    if (customFields && Object.keys(customFields).length > 0) {
      await jiraUtil.updateCustomFields(issueKey, customFields)
    }

    return true
  } catch (error) {
    console.error(`Failed to update ${issueKey}:`, error.message)
    throw error
  }
}

/**
 * Handle pull request events (open, close, etc)
 */
async function handlePullRequestEvent (eventData, jiraUtil) {
  const { action, pull_request } = eventData

  const issueKeys = extractJiraIssueKeys(pull_request)
  if (issueKeys.length === 0) {
    console.log('No Jira issue keys found in PR')
    return
  }

  console.log(`Found Jira issues: ${issueKeys.join(', ')}`)

  let targetStatus = null
  let transitionFields = {}
  let customFields = {}
  const targetBranch = pull_request.base.ref

  switch (action) {
    case 'opened':
    case 'reopened':
    case 'ready_for_review':
      targetStatus = 'Code Review'
      break
    case 'converted_to_draft':
      targetStatus = 'In Development'
      break
    case 'synchronize':
      if (!pull_request.draft) {
        targetStatus = 'Code Review'
      }
      break
    case 'closed':
      if (pull_request.merged) {
        const branchConfig = statusMap[targetBranch]
        if (branchConfig) {
          targetStatus = branchConfig.status
          transitionFields = branchConfig.transitionFields || {}
          customFields = branchConfig.customFields || {}
        } else {
          targetStatus = 'Done'
          transitionFields = { resolution: 'Done' }
        }
      } else {
        console.log('PR closed without merging, skipping status update')
        return
      }
      break
    default:
      console.log('No status updates for action:', action)
      break
  }

  if (targetStatus) {
    for (const issueKey of issueKeys) {
      try {
        await updateIssueWithCustomFields(
          jiraUtil,
          issueKey,
          targetStatus,
          [ 'Blocked', 'Rejected' ],
          transitionFields,
          customFields
        )
      } catch (error) {
        console.error(`Failed to update ${issueKey}:`, error.message)
      }
    }
  }
}

/**
 * Handle push events to branches
 */
async function handlePushEvent (
  branch,
  jiraUtil,
  githubRepository,
  githubToken
) {
  const octokit = new Octokit({
    auth: githubToken,
  })

  const [ githubOwner, repositoryName ] = githubRepository.split('/')
  const { data } = await octokit.rest.repos.getCommit({
    owner: githubOwner,
    repo: repositoryName,
    ref: branch,
    perPage: 1,
    page: 1,
  })

  const {
    commit: { message: commitMessage },
  } = data
  const branchConfig = statusMap[branch]
  if (!branchConfig) {
    console.log(`No status mapping for branch: ${branch}`)
    return
  }

  const newStatus = branchConfig.status
  const transitionFields = branchConfig.transitionFields || {}
  const customFields = branchConfig.customFields || {}

  const shouldCheckCommitHistory = [ 'master', 'main', 'staging' ].includes(
    branch
  )

  const prMatch = commitMessage.match(/#([0-9]+)/)

  // Handle staging to production deployment
  if (branch === 'master' || branch === 'main') {
    console.log('Production deployment: extracting issues from commit history')

    try {
      const commitHistoryIssues = await jiraUtil.getIssueKeysFromCommitHistory(
        'HEAD~100',
        'HEAD'
      )
      if (commitHistoryIssues.length > 0) {
        console.log(
          `Found ${commitHistoryIssues.length} issues in production commit history`
        )

        const updateResults =
          await updateIssuesFromCommitHistoryWithCustomFields(
            jiraUtil,
            commitHistoryIssues,
            newStatus,
            [ 'Blocked', 'Rejected' ],
            transitionFields,
            customFields
          )

        console.log(
          `Production deployment results: ${updateResults.successful} successful, ${updateResults.failed} failed`
        )
      } else {
        console.log('No Jira issues found in production commit history')
      }
    } catch (error) {
      console.error(
        'Error processing production commit history:',
        error.message
      )
    }

    // Also handle direct PR merges to production
    if (prMatch) {
      const prNumber = extractPrNumber(commitMessage)
      const prUrl = `${repositoryName}/pull/${prNumber}`
      if (prNumber) {
        console.log(
          `Also updating issues from PR ${prUrl} to production status`
        )
        await updateByPRWithCustomFields(
          jiraUtil,
          prUrl,
          newStatus,
          transitionFields,
          customFields
        )
      }
    }
    return
  }

  // Handle dev to staging deployment
  if (branch === 'staging') {
    console.log('Staging deployment: extracting issues from commit history')

    try {
      // Get issue keys from commit history
      const commitHistoryIssues =
        await jiraUtil.extractIssueKeysFromGitHubContext(github.context)
      if (commitHistoryIssues.length > 0) {
        console.log(
          `Found ${commitHistoryIssues.length} issues in staging commit history`
        )

        // Update issues found in commit history
        const updateResults =
          await updateIssuesFromCommitHistoryWithCustomFields(
            jiraUtil,
            commitHistoryIssues,
            newStatus,
            [ 'Blocked', 'Rejected' ],
            transitionFields,
            customFields
          )

        console.log(
          `Staging deployment results: ${updateResults.successful} successful, ${updateResults.failed} failed`
        )
        return
      } else {
        console.log('No Jira issues found in staging commit history')
        return
      }
    } catch (error) {
      console.error('Error processing staging commit history:', error.message)
    }

    // Also handle direct PR merges to staging
    if (prMatch) {
      const prNumber = prMatch[1]
      const prUrl = `${repositoryName}/pull/${prNumber}`
      console.log(`Also updating issues from PR ${prUrl} to staging status`)
      await updateByPRWithCustomFields(
        jiraUtil,
        prUrl,
        newStatus,
        transitionFields,
        customFields
      )
    }
    return
  }

  // Handle PR merges to other branches (like dev)
  if (prMatch) {
    const prNumber = prMatch[1]
    const prUrl = `${repositoryName}/pull/${prNumber}`
    console.log(
      `Updating issues mentioning PR ${prUrl} to status: ${newStatus}`
    )
    await updateByPRWithCustomFields(
      jiraUtil,
      prUrl,
      newStatus,
      transitionFields,
      customFields
    )
  }

  // Additionally, for important branches, check commit history for issue keys
  if (shouldCheckCommitHistory) {
    try {
      // Get issue keys from recent commit history (last 50 commits)
      const commitHistoryIssues = await jiraUtil.getIssueKeysFromCommitHistory(
        'HEAD~50',
        'HEAD'
      )

      if (commitHistoryIssues.length > 0) {
        console.log(
          `Found ${commitHistoryIssues.length} additional issues in commit history for ${branch} branch`
        )

        // Update issues found in commit history
        const updateResults =
          await updateIssuesFromCommitHistoryWithCustomFields(
            jiraUtil,
            commitHistoryIssues,
            newStatus,
            [ 'Blocked', 'Rejected' ],
            transitionFields,
            customFields
          )

        console.log(
          `Commit history update results: ${updateResults.successful} successful, ${updateResults.failed} failed`
        )
      }
    } catch (error) {
      console.error('Error processing commit history:', error.message)
      // Don't fail the entire action if commit history processing fails
    }
  }
}

/**
 * Update issues from commit history with separate custom field updates
 */
async function updateIssuesFromCommitHistoryWithCustomFields (
  jiraUtil,
  issueKeys,
  targetStatus,
  excludeStates,
  transitionFields,
  customFields
) {
  if (!issueKeys || issueKeys.length === 0) {
    console.log('No issue keys provided for update')
    return { successful: 0, failed: 0, errors: [] }
  }

  console.log(`Updating ${issueKeys.length} issues to status: ${targetStatus}`)

  const results = await Promise.allSettled(
    issueKeys.map((issueKey) =>
      updateIssueWithCustomFields(
        jiraUtil,
        issueKey,
        targetStatus,
        excludeStates,
        transitionFields,
        customFields
      )
    )
  )

  const successful = results.filter(
    (result) => result.status === 'fulfilled'
  ).length
  const failed = results.filter((result) => result.status === 'rejected')
  const errors = failed.map(
    (result) => result.reason?.message || 'Unknown error'
  )

  console.log(
    `Update summary: ${successful} successful, ${failed.length} failed`
  )
  if (failed.length > 0) {
    console.log('Failed updates:', errors)
  }

  return {
    successful,
    failed: failed.length,
    errors,
  }
}

/**
 * Update issues by PR with separate custom field updates
 */
async function updateByPRWithCustomFields (
  jiraUtil,
  prUrl,
  newStatus,
  transitionFields,
  customFields
) {
  try {
    const jql = `text ~ "${prUrl}"`
    const response = await jiraUtil.request('/search/jql', {
      method: 'POST',
      body: JSON.stringify({
        jql,
        fields: [ 'key', 'summary', 'status', 'description' ],
        maxResults: 50,
      }),
    })

    const data = await response.json()
    const issues = data.issues
    console.log(`Found ${issues.length} issues mentioning PR ${prUrl}`)

    for (const issue of issues) {
      await updateIssueWithCustomFields(
        jiraUtil,
        issue.key,
        newStatus,
        [ 'Blocked', 'Rejected' ],
        transitionFields,
        customFields
      )
    }

    return issues.length
  } catch (error) {
    console.error(`Error updating issues by PR:`, error.message)
    throw error
  }
}

/**
 * Extract Jira issue keys from PR title or body
 * @param {Object} pullRequest - GitHub PR object
 * @returns {Array<string>} Array of Jira issue keys
 */
function extractJiraIssueKeys (pullRequest) {
  const jiraKeyPattern = /[A-Z]+-[0-9]+/g
  const keys = new Set()

  if (pullRequest.title) {
    const titleMatches = pullRequest.title.match(jiraKeyPattern)
    if (titleMatches) {
      titleMatches.forEach((key) => keys.add(key))
    }
  }

  return Array.from(keys)
}

/**
 * Extract PR number from commit message
 * @param {string} commitMessage - Git commit message
 * @returns {string|null} PR number or null if not found
 */
function extractPrNumber (commitMessage) {
  const prMatch = commitMessage.match(/#([0-9]+)/)
  return prMatch ? prMatch[1] : null
}

// Export helpers for testability
module.exports = Object.assign(module.exports || {}, {
  maskSensitive,
  detectEnvironment,
})
